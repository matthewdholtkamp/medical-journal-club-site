<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medical Journal Club</title>
    <style>
        /* --- Dark Theme Colors --- */
        :root {
            --bg-primary: #1a1a2e; /* Dark Blue-Purple */
            --bg-secondary: #0f3460; /* Slightly lighter for containers */
            --text-primary: #e0e0e0; /* Light gray text */
            --text-secondary: #a0a0a0; /* Muted text */
            --accent-color: #e94560; /* Vibrant Red/Pink for accents */
            --title-color: #F39C12; /* Orange for title */
            --button-bg: #533483; /* Darker purple for main buttons */
            --button-hover-bg: #63409a;
            --input-bg: #2a2a4a;
            --input-border: #444466;
            --header-bg: #16213e; /* Even darker header */
            --disclaimer-bg: #2b2b4e;
            --disclaimer-border: #4a4a6e;
            --disclaimer-text: #b0b0d0;
            --toolbar-bg: #232946;
            --tab-inactive: #a0a0a0;
            --tab-active: var(--accent-color);
            --tab-border: #3a3a5e;
            --code-bg: #232a3f;
            --code-border: #3a4a6e;
        }

        /* --- Basic Setup --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: var(--bg-secondary);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        /* --- Header & Disclaimer --- */
        header {
            padding: 24px 32px;
            background-color: var(--header-bg);
            color: var(--text-primary);
        }
        header h1 {
            margin: 0;
            font-size: 2.00rem;
            text-align: center;
            color: var(--title-color);
        }
        .disclaimer {
            background-color: var(--disclaimer-bg);
            color: var(--disclaimer-text);
            border: 1px solid var(--disclaimer-border);
            padding: 16px;
            margin: 32px;
            border-radius: 6px;
            font-size: 0.9rem;
            text-align: center;
        }

        /* --- Form Inputs (Shared Styles) --- */
        .form-section {
            padding: 0 32px 32px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        .form-group {
            display: flex;
            flex-direction: column;
        }
        .form-group label {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.95rem;
            color: var(--text-primary);
        }
        .form-group label span {
            font-weight: 400;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        .form-group input[type="text"] {
            padding: 12px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            font-size: 1rem;
            background-color: var(--input-bg);
            color: var(--text-primary);
        }
        .form-group input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(233, 69, 96, 0.3);
        }
        .form-button {
            background-color: var(--button-bg);
            color: var(--text-primary);
            padding: 14px;
            border: none;
            border-radius: 6px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 10px;
        }
        .form-button:hover {
            background-color: var(--button-hover-bg);
        }
        .form-button:disabled {
            background-color: #4a4a6a;
            cursor: not-allowed;
            color: #888;
        }

        /* --- Refinement Area Specifics --- */
        #refinementForm h3 {
            margin: 0 0 10px 0;
            color: var(--text-primary);
            border-bottom: 1px solid var(--tab-border);
            padding-bottom: 10px;
        }
        
        #refinementForm .form-button {
            background-color: var(--accent-color); /* Make second button stand out */
        }
        #refinementForm .form-button:hover {
            background-color: #c73a52;
        }


        /* --- Loader --- */
        #loader {
            display: none; /* Hidden by default */
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }
        .spinner {
            border: 4px solid var(--input-border);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- Results Section --- */
        #results {
            padding: 0;
        }
        .hidden {
            display: none;
        }

        /* Action Toolbar */
        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 16px 32px;
            background-color: var(--toolbar-bg);
            border-bottom: 1px solid var(--tab-border);
        }
        .toolbar button {
            background-color: var(--input-bg);
            color: var(--text-primary);
            border: 1px solid var(--input-border);
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        .toolbar button:hover {
            background-color: #3a3a5e;
        }
        .toolbar button#btnAudio {
            background-color: #3c6e71; /* A green-ish accent for audio */
            border-color: #5c8b8e;
            color: #e0f2f1;
        }
        .toolbar button#btnAudio:hover {
            background-color: #4c8a8e;
        }
        .toolbar button:disabled {
            background-color: #33334f;
            color: #777;
            cursor: not-allowed;
            border-color: #4a4a6a;
        }
        
        /* Audio Player */
        #audioPlayer {
            width: calc(100% - 64px); /* Full width minus padding */
            margin: 16px 32px 0 32px;
        }
        #audioPlayer.hidden {
            display: none;
        }


        /* Tabs */
        .tab-nav {
            display: flex;
            border-bottom: 1px solid var(--tab-border);
            padding: 0 32px;
            margin-top: 16px; /* Add margin above tabs if audio player is visible */
        }
        .tab-nav button {
            padding: 14px 20px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            color: var(--tab-inactive);
            border-bottom: 3px solid transparent;
            margin-bottom: -1px;
        }
        .tab-nav button.active {
            color: var(--tab-active);
            border-bottom-color: var(--tab-active);
        }

        /* Tab Content */
        .tab-content {
            padding: 24px 32px 32px;
        }
        /* Custom message box for alerts */
        #messageBox {
            display: none;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--accent-color);
            color: var(--text-primary);
            padding: 16px 24px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        #messageBox.show {
            display: block;
            opacity: 1;
        }

        #summaryContent, #planContent { /* Added #planContent */
            white-space: pre-wrap; /* Preserves formatting */
            line-height: 1.7;
            font-family: "Georgia", serif;
            color: var(--text-primary);
        }
        #referencesContent {
            white-space: pre-wrap;
            line-height: 1.6;
            font-family: "Courier New", monospace;
            font-size: 0.9rem;
            background-color: var(--code-bg);
            padding: 16px;
            border-radius: 4px;
            border: 1px solid var(--code-border);
            color: var(--text-secondary);
        }
        #sourcesContent ul {
            list-style-type: none;
            padding-left: 0;
        }
        #sourcesContent li {
            margin-bottom: 12px;
        }
        #sourcesContent a {
            color: var(--accent-color);
            text-decoration: none;
            font-weight: 500;
        }
        #sourcesContent a:hover {
            text-decoration: underline;
        }
    </style>
    
    <!-- ADDED THIS SCRIPT to render math symbols like ≥, ≈, etc. -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

    <div class="container">
        <header>
            <h1>Evidence-to-Action</h1>
        </header>
        
        <p class="disclaimer">
            <strong>For educational and informational purposes only.</strong> This tool does not provide medical advice and is not a substitute for professional clinical judgment.
        </p>

        <!-- --- STEP 1: Initial Question Form --- -->
        <form id="queryForm" class="form-section">
            <div class="form-group">
                <label for="initialQuestion">1. Enter a Medical Topic or Question
                    <span>e.g., "new treatments for sepsis," "management of status epilepticus"</span>
                </label>
                <input type="text" id="initialQuestion" required>
            </div>
            <button type="submit" id="refineButton" class="form-button">Refine Topic</button>
        </form>
        
        <!-- --- STEP 2: Refinement Questions (hidden by default) --- -->
        <form id="refinementForm" class="form-section hidden">
            <h3>Please refine your topic:</h3>
            <div id="dynamicFormContainer">
                <!-- Generated free-text inputs will be injected here -->
            </div>
            <button type="submit" id="generateButton" class="form-button">Generate Summary</button>
        </form>

        <!-- --- STEP 3: Loader --- -->
        <div id="loader">
            <div class="spinner"></div>
            <p id="loaderText">Synthesizing medical literature...</p>
        </div>

        <!-- --- STEP 4: Results --- -->
        <div id="results" class="hidden">
            <!-- Action Toolbar -->
            <div class="toolbar">
                <button id="btnAudio">Generate Audio Lecture (.wav)</button>
                <button id="btnKeyPoints">Download Key Points (.txt)</button>
                <button id="btnCopySummary">Copy Summary</button>
                <button id="btnCopyRefs">Copy References</button>
            </div>
            
            <!-- NEW: Audio Player -->
            <audio id="audioPlayer" controls class="hidden"></audio>

            <!-- Tab Navigation -->
            <nav class="tab-nav">
                <button class="tab-link active" data-tab="summary">Journal Club Summary</button>
                <!-- NEW "Treatment & Plan" TAB -->
                <button class="tab-link" data-tab="plan">Treatment & Plan</button>
                <button class="tab-link" data-tab="references">APA References</button>
                <button class="tab-link" data-tab="sources">Verified Sources</button>
            </nav>

            <!-- Tab Content -->
            <div id="summary" class="tab-content">
                <div id="summaryContent"></div>
            </div>
            <!-- NEW "Treatment & Plan" CONTENT -->
            <div id="plan" class="tab-content hidden">
                <div id="planContent"></div>
            </div>
            <div id="references" class="tab-content hidden">
                <div id="referencesContent"></div>
            </div>
            <div id="sources" class="tab-content hidden">
                <div id="sourcesContent"></div>
            </div>
        </div>
    </div>

    <!-- Message box for copy confirmations, etc. -->
    <div id="messageBox"></div>

    <!-- Helper functions for inlined pcm-to-wav library -->
    <script>
        var newArrayBuffer = function(size) { return new ArrayBuffer(size); };
        var newDataView = function(buffer) { return new DataView(buffer); };
        var newUint8Array = function(buffer, offset) { return new Uint8Array(buffer, offset); };
        var newBlob = function(parts, options) { return new Blob(parts, options); };
    </script>
    <!-- Inlined pcm-to-wav library to prevent load errors -->
    <script>
    !function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.pcmToWav=t():e.pcmToWav=t()}(window,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){var n,o,a,i,f,c,u,d=newDataView(newArrayBuffer(44+e.length*t*2));return d.setUint32(0,1380533830,!1),d.setUint32(4,36+e.length*t*2,!0),d.setUint32(8,1463899717,!1),d.setUint32(12,1718449184,!1),d.setUint32(16,16,!0),d.setUint16(20,1,!0),n=t,d.setUint16(22,n,!0),o=r,d.setUint32(24,o,!0),a=r*t*2,d.setUint32(28,a,!0),i=2*t,d.setUint16(32,i,!0),f=16,d.setUint16(34,f,!0),d.setUint32(36,1684108385,!1),c=e.length*t*2,d.setUint32(40,c,!0),u=newUint8Array(d.buffer,44),e.forEach(function(e,t){var r=44+2*t;d.setInt16(r,e,!0)}),newBlob([d.buffer],{type:"audio/wav"})},e.exports=t.default}])});
    </script>

    <script>
        // --- API Configuration ---
        // !!! IMPORTANT: Replace "YOUR_API_KEY" with your actual Google AI API key
        const API_KEY = "AIzaSyB4icRH1sBnW4nFfVbM2vocXDzpxQsdPoI"; // PASTE YOUR KEY HERE
        
        // Model for text generation (with search)
        const GENERATE_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        
        // Model for Text-to-Speech (TTS)
        const TTS_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${API_KEY}`;


        // --- DOM Element References ---
        const queryForm = document.getElementById('queryForm');
        const refineButton = document.getElementById('refineButton');
        const initialQuestionInput = document.getElementById('initialQuestion');
        
        const refinementForm = document.getElementById('refinementForm');
        const dynamicFormContainer = document.getElementById('dynamicFormContainer');
        const generateButton = document.getElementById('generateButton');
        
        const loader = document.getElementById('loader');
        const loaderText = document.getElementById('loaderText');
        const results = document.getElementById('results');
        
        const summaryContent = document.getElementById('summaryContent');
        const planContent = document.getElementById('planContent'); // NEW: Treatment Plan
        const referencesContent = document.getElementById('referencesContent');
        const sourcesContent = document.getElementById('sourcesContent');
        
        const tabLinks = document.querySelectorAll('.tab-link');
        const tabContents = document.querySelectorAll('.tab-content');

        const btnAudio = document.getElementById('btnAudio');
        const btnKeyPoints = document.getElementById('btnKeyPoints');
        const btnCopySummary = document.getElementById('btnCopySummary');
        const btnCopyRefs = document.getElementById('btnCopyRefs');
        
        const messageBox = document.getElementById('messageBox');
        const audioPlayer = document.getElementById('audioPlayer');

        // --- Global State ---
        let currentSummary = ""; // Stores the main summary for reuse
        let currentAudioUrl = null; // Stores the URL for the playable audio

        // --- Event Listeners ---
        queryForm.addEventListener('submit', handleInitialSubmit);
        refinementForm.addEventListener('submit', handleSummaryFormSubmit);
        
        btnKeyPoints.addEventListener('click', handleDownloadKeyPoints);
        btnAudio.addEventListener('click', handleDownloadAudio);
        btnCopySummary.addEventListener('click', () => copyToClipboard(summaryContent.innerText, 'Summary')); // Use innerText
        btnCopyRefs.addEventListener('click', () => copyToClipboard(referencesContent.innerText, 'References'));

        tabLinks.forEach(link => {
            link.addEventListener('click', () => {
                const tabId = link.getAttribute('data-tab');
                
                // Update tab links
                tabLinks.forEach(l => l.classList.remove('active'));
                link.classList.add('active');

                // Update tab content
                tabContents.forEach(content => {
                    if (content.id === tabId) {
                        content.classList.remove('hidden');
                    } else {
                        content.classList.add('hidden');
                    }
                });
            });
        });


        // --- Core Functions ---
        
        /**
         * Generic function to make API calls with exponential backoff.
         */
        async function fetchWithRetry(url, payload, maxRetries = 3) {
            let attempt = 0;
            while (attempt < maxRetries) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 || response.status === 503) { // Throttling or Overloaded
                        const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                        await new Promise(res => setTimeout(res, delay));
                        attempt++;
                        continue;
                    }

                    if (!response.ok) {
                        const errorBody = await response.json(); // Try to parse JSON error
                        console.error("API Error Body:", errorBody);
                        const errorMsg = errorBody?.error?.message || `API Error: ${response.status} ${response.statusText}`;
                        // Specific check for 503 in error body
                        if (errorBody?.error?.status === "UNAVAILABLE" || response.status === 503) {
                           throw new Error("The AI model is currently overloaded (503). Please try again in a moment.");
                        }
                        throw new Error(errorMsg);
                    }
                    
                    return await response.json();

                } catch (error) {
                    attempt++;
                    if (attempt >= maxRetries) {
                         // If it's the specific 503 message, just re-throw it
                        if (error.message.includes("503")) {
                            throw error;
                        }
                        // Otherwise, throw a generic retry-failed error
                        throw new Error(`API call failed after ${maxRetries} attempts: ${error.message}`);
                    }
                }
            }
        }


        /**
         * 1. Handles the INITIAL form submission (Step 1)
         */
        async function handleInitialSubmit(e) {
            e.preventDefault();
            
            if (API_KEY === "" || API_KEY === "YOUR_API_KEY") {
                showMessage("Error: Please add your Google AI API key to the index.html file.");
                return;
            }
            
            // 1. Get user input
            const initialQuestion = initialQuestionInput.value;
            if (!initialQuestion) return;

            // 2. Construct the "Refinement" prompt
            const refinementPrompt = `
                You are a medical research assistant. Based on the user's topic: "${initialQuestion}", generate exactly 5 specific, high-yield follow-up questions to help them narrow their focus for a literature review. These questions will be used as labels for free-text input fields.
                
                Provide your response as a list of questions, each on a new line, prefixed with "Q:".
                Make them sound like PICO categories.
                
                Example:
                Q: What is the specific Patient Population or Problem (P)?
                Q: What is the Intervention being studied (I)?
                Q: What is the Comparison or Control group (C)?
                Q: What are the primary Outcome(s) of interest (O)?
                Q: What Study Types or Timeframe should be prioritized?
            `;

            // 3. Show loader and hide old results/questions
            loaderText.innerText = "Generating refinement questions...";
            loader.style.display = 'block';
            results.classList.add('hidden');
            audioPlayer.classList.add('hidden'); // Hide old audio player
            if (currentAudioUrl) {
                URL.revokeObjectURL(currentAudioUrl); // Revoke old audio URL
                currentAudioUrl = null;
            }
            refinementForm.classList.add('hidden');
            refineButton.disabled = true;
            
            // 4. Call the API (no search tool needed for this step)
            try {
                const payload = {
                    "contents": [{ "parts": [{ "text": refinementPrompt }] }]
                };

                const apiData = await fetchWithRetry(GENERATE_API_URL, payload);
                
                const candidate = apiData.candidates?.[0];
                if (!candidate || !candidate.content?.parts?.[0]?.text) {
                    throw new Error("Invalid API response structure for refinement.");
                }

                const rawText = candidate.content.parts[0].text;
                // Parse the text response
                const questions = rawText.split('\n')
                                         .filter(line => line.startsWith('Q:'))
                                         .map(line => line.substring(3).trim());
                
                if (questions.length === 0) {
                    // Fallback in case the model doesn't follow the 'Q:' prefix
                    const fallbackQuestions = rawText.split('\n').filter(line => line.trim().length > 0 && line.includes('?'));
                    if (fallbackQuestions.length > 0) {
                         displayRefinementForm(fallbackQuestions);
                    } else {
                        // Hardcoded fallback if AI fails
                        const defaultQuestions = [
                            "What is the specific Patient Population or Problem (P)?",
                            "What is the Intervention being studied (I)?",
                            "What is the Comparison or Control group (C)?",
                            "What are the primary Outcome(s) of interest (O)?",
                            "What Study Types or Timeframe should be prioritized?"
                        ];
                        displayRefinementForm(defaultQuestions);
                    }
                } else {
                    displayRefinementForm(questions);
                }

            } catch (error) {
                console.error('Error fetching refinement questions:', error);
                loaderText.innerText = `Error: ${error.message}. Please check your API key and console.`;
            } finally {
                refineButton.disabled = false;
                // Keep loader hidden, it's handled by displayRefinementForm
            }
        }
        
        /**
         * 2. Displays the 5 refinement questions as free-text inputs (Step 2)
         */
        function displayRefinementForm(questions) {
            dynamicFormContainer.innerHTML = ''; // Clear old form
            
            if (!questions || questions.length === 0) {
                dynamicFormContainer.innerHTML = '<p>Could not generate follow-up questions. Please try again.</p>';
            } else {
                questions.forEach((question, index) => {
                    const formGroup = document.createElement('div');
                    formGroup.className = 'form-group';
                    
                    const label = document.createElement('label');
                    label.setAttribute('for', `refinement_input_${index}`);
                    label.innerText = question;
                    
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.id = `refinement_input_${index}`;
                    input.className = 'refinement-input';
                    
                    formGroup.appendChild(label);
                    formGroup.appendChild(input);
                    dynamicFormContainer.appendChild(formGroup);
                });
            }

            loader.style.display = 'none';
            refinementForm.classList.remove('hidden');
        }

        /**
         * 3. Handles the click on the "Generate Summary" button (Step 3)
         */
        async function handleSummaryFormSubmit(e) {
            e.preventDefault();
            
            // 1. Gather all the data from the dynamic form
            const inputs = dynamicFormContainer.querySelectorAll('.refinement-input');
            const labels = dynamicFormContainer.querySelectorAll('label');
            let structuredQuery = "";
            
            labels.forEach((label, index) => {
                const question = label.innerText;
                const answer = inputs[index].value;
                if (answer.trim() !== "") { // Only include non-empty fields
                    structuredQuery += `- ${question}: ${answer}\n`;
                }
            });

            if (structuredQuery === "") {
                showMessage("Please fill out at least one refinement field.");
                return;
            }

            const initialTopic = initialQuestionInput.value;
            
            // 2. Construct the main prompt using the structured query
            //    UPDATED to ask for all 3 sections
            const mainPrompt = `
                You are an expert medical researcher and synthesizer. Your task is to perform a literature review based on an initial topic and the user's refined parameters.
                
                **Initial Topic:**
                ${initialTopic}
                
                **Refined Parameters:**
                ${structuredQuery}
                
                **Instructions:**
                1.  Synthesize the user's parameters to answer their implied clinical question.
                2.  You **MUST** use the Google Search tool to find relevant, up-to-date and reputable sources that match the user's parameters.
                3.  Prioritize guidelines from professional societies (AHA, ASA, SCCM) and high-impact journals (NEJM, JAMA, The Lancet, PubMed).
                4.  **FORMATTING:** The output must be plain text. Do not use any bolding, italics, markdown, tables, or other special styling. Use standard paragraphs.
                
                **Output Format (MANDATORY):**
                
                FIRST, provide the complete "Journal Club" summary. It must include these subheadings:
                Introduction and Background
                Key Studies and Methodology
                Key Findings
                Discussion and Clinical Bottom Line
                
                SECOND, insert the exact delimiter "---TREATMENT_PLAN---".
                
                THIRD, provide a "Treatment and Plan" section. This must be an evidence-based, stepwise medical workup and a stepwise treatment plan. Use simple numbered lists or paragraphs.
                
                FOURTH, insert the exact delimiter "---APA_REFERENCES---".
                
                FIFTH, provide the complete list of all cited articles in APA 7th edition format.
            `;

            // 3. Show loader and hide refinement form
            loaderText.innerText = "Synthesizing medical literature...";
            loader.style.display = 'block';
            results.classList.add('hidden');
            audioPlayer.classList.add('hidden'); // Hide old audio player
            if (currentAudioUrl) {
                URL.revokeObjectURL(currentAudioUrl); // Revoke old audio URL
                currentAudioUrl = null;
            }
            refinementForm.classList.add('hidden');
            refineButton.disabled = true; 
            generateButton.disabled = true;

            // 4. Call the API (WITH search tool)
            try {
                const payload = {
                    "contents": [{ "parts": [{ "text": mainPrompt }] }],
                    "tools": [{ "google_search": {} }] // This enables the search tool
                };

                const apiData = await fetchWithRetry(GENERATE_API_URL, payload);
                
                const candidate = apiData.candidates?.[0];
                if (!candidate || !candidate.content?.parts?.[0]?.text) {
                    throw new Error("Invalid API response structure or empty response from model.");
                }

                // Extract the raw text and parse it based on our custom delimiters
                const rawText = candidate.content.parts[0].text;
                
                const planSplit = rawText.split('---TREATMENT_PLAN---');
                const summary = planSplit[0]?.trim() || "";
                
                const refSplit = (planSplit[1] || "").split('---APA_REFERENCES---');
                const plan = refSplit[0]?.trim() || "";
                const refs = refSplit[1]?.trim() || "";
                
                let parsedData = {};
                
                if (!summary || (!plan && !refs)) {
                     // Model failed to follow instructions, just show the raw text as summary
                    console.error("Response format error: Could not find delimiters.");
                    parsedData = {
                        journalClubSummary: rawText.trim(),
                        treatmentPlan: "Could not parse treatment plan from response.",
                        apaReferences: "Could not parse references from response. See summary for details."
                    };
                } else if (!plan || !refs) {
                    // Model returned summary but failed on one of the others
                    console.error("Response format error: Missing plan or references delimiter.");
                    // Check if it missed the plan but got the refs
                    const recoveryRefSplit = rawText.split('---APA_REFERENCES---');
                    if (recoveryRefSplit.length > 1) {
                         parsedData = {
                            journalClubSummary: recoveryRefSplit[0].trim(),
                            treatmentPlan: "Could not parse treatment plan from response.",
                            apaReferences: recoveryRefSplit[1].trim()
                        };
                    } else {
                         parsedData = {
                            journalClubSummary: summary,
                            treatmentPlan: plan || "Could not parse treatment plan from response.",
                            apaReferences: "Could not parse references from response."
                        };
                    }
                } else {
                    // Successful parse
                    parsedData = {
                        journalClubSummary: summary,
                        treatmentPlan: plan,
                        apaReferences: refs
                    };
                }
                
                // Get source citations (grounding metadata)
                let citations = [];
                const groundingMetadata = candidate.groundingMetadata;
                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                    citations = groundingMetadata.groundingAttributions
                        .map(attr => ({
                            uri: attr.web?.uri,
                            title: attr.web?.title,
                        }))
                        .filter(source => source.uri && source.title);
                }
                
                displayResults(parsedData, citations);


            } catch (error)
            {
                console.error('Error fetching summary:', error);
                // Check for the specific 503 error message
                if (error.message.includes("503")) {
                    loaderText.innerText = error.message; // Show the user-friendly 503 message
                } else {
                    loaderText.innerText = `Error: ${error.message}. Please check your API key and console.`;
                }
            } 
            finally 
            {
                refineButton.disabled = false; // Re-enable main button
                generateButton.disabled = false; // Re-enable summary button
            }
        }

        /**
         * 4. Displays the final results from the API call (Step 4)
         */
        function displayResults(data, citations) {
            // 1. Store and populate text
            currentSummary = data.journalClubSummary; // Only store the summary for audio/key points
            summaryContent.innerText = data.journalClubSummary;
            planContent.innerText = data.treatmentPlan; // NEW: Populate plan
            referencesContent.innerText = data.apaReferences;

            // This is the key part for MathJax:
            // After setting the text, we need to tell MathJax to look for and typeset any new math.
            if (window.MathJax) {
                // Tell MathJax to typeset all three content areas
                window.MathJax.typesetPromise([summaryContent, planContent])
                    .catch((err) => console.log('MathJax Typeset Error: ', err));
            }


            // 2. Populate sources
            sourcesContent.innerHTML = ''; // Clear old sources
            if (citations && citations.length > 0) {
                const list = document.createElement('ul');
                citations.forEach(source => {
                    const item = document.createElement('li');
                    const link = document.createElement('a');
                    link.href = source.uri;
                    link.textContent = source.title || source.uri;
                    link.target = "_blank"; // Open in new tab
                    item.appendChild(link);
                    list.appendChild(item);
                });
                sourcesContent.appendChild(list);
            } else {
                sourcesContent.innerHTML = '<p>No direct source URLs were returned by the API for this query.</p>';
            }
            
            // 3. Hide loader and show results
            loader.style.display = 'none';
            results.classList.remove('hidden');

            // 4. Reset to the first tab
            tabLinks.forEach(l => l.classList.remove('active'));
            tabContents.forEach(c => c.classList.add('hidden'));
            document.querySelector('.tab-link[data-tab="summary"]').classList.add('active');
            document.getElementById('summary').classList.remove('hidden');
        }

        /**
         * 5. Handles the "Download Key Points" button click.
         */
        async function handleDownloadKeyPoints() {
            if (!currentSummary) return;

            loaderText.innerText = "Generating key points...";
            loader.style.display = 'block';
            btnKeyPoints.disabled = true;

            const keyPointsPrompt = `
                You are a medical educator. Convert the following journal club summary into a concise, 'high-yield' bulleted list of key takeaways for a busy clinician.
                Focus on the clinical bottom line and actionable points. 
                **FORMATTING:** Do not use markdown, bolding, or any other styling for the output. Just plain text bullet points (using a hyphen - or asterisk *).
                
                SUMMARY:
                ---
                ${currentSummary}
                ---
            `;
            
            try {
                const payload = {
                    "contents": [{ "parts": [{ "text": keyPointsPrompt }] }]
                };
                
                const apiData = await fetchWithRetry(GENERATE_API_URL, payload);

                const candidate = apiData.candidates?.[0];
                if (!candidate || !candidate.content?.parts?.[0]?.text) {
                    throw new Error("Invalid API response structure or empty response from model.");
                }

                const keyPointsText = candidate.content.parts[0].text;
                
                downloadAsFile('key_points.txt', new Blob([keyPointsText], { type: 'text/plain' }));

            } catch (error) {
                console.error('Error generating key points:', error);
                showMessage(`Error generating key points: ${error.message}`);
            } finally {
                loader.style.display = 'none';
                btnKeyPoints.disabled = false;
            }
        }

        /**
         * 6. Handles "Generate Audio" button.
         */
        async function handleDownloadAudio() {
            if (!currentSummary) return;

            loaderText.innerText = "Generating 5-7 minute lecture script...";
            loader.style.display = 'block';
            btnAudio.disabled = true;
            
            // 1. Clean the summary text for both prompts
            let plainTextSummary = currentSummary;
            // Simple regex to strip TeX-like commands
            plainTextSummary = plainTextSummary.replace(/\\\[.*?\\\]/g, ' '); // block math
            plainTextSummary = plainTextSummary.replace(/\\\(.*?\\\)/g, ' '); // inline math
            plainTextSummary = plainTextSummary.replace(/\$.*?\$/g, ' '); // dollar sign math
            plainTextSummary = plainTextSummary.replace(/\\(approx|geq|leq|pm|times|cdot|etc)/g, ' '); // common symbols
            plainTextSummary = plainTextSummary.replace(/\{|\}/g, ' '); // curly braces
            plainTextSummary = plainTextSummary.replace(/\s\s+/g, ' '); // clean up extra whitespace

            
            // 2. First API Call: Generate the 5-7 minute lecture script
            const lectureScriptPrompt = `
                You are a medical lecturer. Take the following journal club summary and expand it into a 5 to 7 minute audio lecture script (approximately 800-1000 words).
                Introduce the topic, explain the key studies and findings in detail, and conclude with the clinical bottom line. 
                Write in a clear, spoken, and professional style. Do not use any markdown or special formatting. Just plain text.
                
                SUMMARY:
                ---
                ${plainTextSummary}
                ---
            `;

            try {
                const lecturePayload = {
                    "contents": [{ "parts": [{ "text": lectureScriptPrompt }] }]
                };
                
                const lectureApiData = await fetchWithRetry(GENERATE_API_URL, lecturePayload);
                
                const lectureCandidate = lectureApiData.candidates?.[0];
                if (!lectureCandidate || !lectureCandidate.content?.parts?.[0]?.text) {
                    throw new Error("Failed to generate lecture script.");
                }
                const lectureScript = lectureCandidate.content.parts[0].text;

                // 3. Second API Call: Convert the lecture script to speech
                loaderText.innerText = "Generating audio file... This may take a moment.";
                
                // Polished intro
                // UPDATED: Added pronunciation guidance
                const ttsPrompt = `Say in a clear, professional, and knowledgeable tone. Pay special attention to the correct pronunciation of all medical and pharmacological terms: This presentation is brought to you by Dr. Matthew Holtkamp.${lectureScript}`;

                const ttsPayload = {
                    "contents": [{ "parts": [{ "text": ttsPrompt }] }],
                    "generationConfig": {
                        "responseModalities": ["AUDIO"],
                        "speechConfig": {
                            // UPDATED: Changed voice from Charon to Sadaltager (Knowledgeable)
                            "voiceConfig": { "prebuiltVoiceConfig": { "voiceName": "Sadaltager" } }
                        }
                    },
                    "model": "gemini-2.5-flash-preview-tts"
                };

                const ttsApiData = await fetchWithRetry(TTS_API_URL, ttsPayload);

                const part = ttsApiData.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (!audioData || !mimeType || !mimeType.startsWith("audio/L16")) {
                    throw new Error("Invalid audio data received from API.");
                }

                const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000; // Default to 24kHz if not specified

                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                
                if (typeof window.pcmToWav !== 'function') {
                    throw new Error("Audio conversion library (pcmToWaw) failed to load.");
                }
                
                const wavBlob = window.pcmToWav(pcm16, 1, sampleRate); // 1 channel, specified sample rate
                
                // 4. Set up the audio player
                if (currentAudioUrl) {
                    URL.revokeObjectURL(currentAudioUrl); // Revoke the old URL if it exists
                }
                currentAudioUrl = URL.createObjectURL(wavBlob);
                audioPlayer.src = currentAudioUrl;
                audioPlayer.classList.remove('hidden');
                audioPlayer.load();
                
                // 5. Trigger the download
                downloadAsFile('audio_lecture.wav', wavBlob);
                
                showMessage("Audio lecture generated and download started.");

            } catch (error) {
                console.error('Error generating audio:', error);
                showMessage(`Error generating audio: ${error.message}`);
            } finally {
                loader.style.display = 'none';
                btnAudio.disabled = false;
            }
        }

        /**
         * 7. Utility function to copy text to the clipboard.
         */
        async function copyToClipboard(text, item) {
            
            let cleanText = text;
            
            // This function tells MathJax to get the plain-text from the rendered math
            const getCleanText = async (elementId) => {
                const element = document.getElementById(elementId);
                if (!element) return text; // Fallback

                // Clean text only if MathJax has loaded
                if (window.MathJax && typeof window.MathJax.typesetPromise === 'function' && window.MathJax.startup?.document) {
                    try {
                        // Get the MathJax document
                        const mjDoc = window.MathJax.startup.document;
                        // Find the typeset element
                        const mjElement = mjDoc.getElementById(elementId);
                        if (mjElement) {
                             // Use MathJax's internal method to get text
                             let visitor = new window.MathJax.core.MmlTree.SerializedMmlVisitor();
                             cleanText = visitor.visitTree(mjElement);
                             // This might return MML, let's try innerText as a better fallback
                             cleanText = element.innerText;
                        } else {
                            cleanText = element.innerText; // Fallback if not found
                        }
                    } catch(err) {
                         console.error('MathJax text conversion failed:', err);
                         cleanText = element.innerText; // Fallback
                    }
                } else {
                    // Fallback if MathJax isn't ready
                    cleanText = element.innerText;
                }
                return cleanText;
            };

            // Get the clean text from the specific element
            if (item === 'Summary') {
                 cleanText = await getCleanText('summaryContent');
            } else if (item === 'Treatment & Plan') { // Added this
                 cleanText = await getCleanText('planContent');
            } else {
                 cleanText = text; // References don't need cleaning
            }


            // Using document.execCommand as a fallback for iframe/secure context issues
            try {
                const textArea = document.createElement("textarea");
                textArea.value = cleanText;
                textArea.style.position = "fixed";  // Avoid scrolling to bottom
                textArea.style.opacity = "0";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessage(`${item} copied to clipboard!`);
                } else {
                    throw new Error('execCommand failed');
                }
            } catch (err) {
                // Fallback for modern browsers (might fail in sandboxed iframes)
                navigator.clipboard.writeText(cleanText).then(() => {
                    showMessage(`${item} copied to clipboard!`);
                }, (err) => {
                    console.error('Failed to copy text: ', err);
                    showMessage('Failed to copy. See console for errors.');
                });
            } finally {
                const textArea = document.querySelector("textarea");
                if (textArea) {
                    document.body.removeChild(textArea);
                }
            }
        }

        /**
         * 8. Utility function to trigger a file download.
         */
        function downloadAsFile(filename, blob) {
            const blobUrl = (blob instanceof Blob) ? URL.createObjectURL(blob) : blob;
            
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = filename;
            document.body.appendChild(a);
a.click();
            
            // Clean up
            document.body.removeChild(a);
            // Don't revoke URL immediately if it's for the player
            if (filename !== 'audio_lecture.wav') {
                 URL.revokeObjectURL(blobUrl);
            }
        }
        
        /**
         * 9. Utility function to show a custom message.
         */
        function showMessage(message) {
            messageBox.innerText = message;
            messageBox.classList.add('show');
            
            // Hide after 3 seconds
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3000);
        }
        
        /**
         * 10. Utility to convert Base64 to ArrayBuffer (for audio).
         */
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

    </script>
</body>
</html>

